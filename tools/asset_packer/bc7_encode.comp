#version 460

#define CHAR_LENGTH 8
#define NCHANNELS 4
#define	BC7_UNORM 98
#define MAX_UINT 0xFFFFFFFF
#define MIN_UINT 0

const uint candidateSectionBit[64] = //Associated to partition 0-63
{
    0xCCCC, 0x8888, 0xEEEE, 0xECC8,
    0xC880, 0xFEEC, 0xFEC8, 0xEC80,
    0xC800, 0xFFEC, 0xFE80, 0xE800,
    0xFFE8, 0xFF00, 0xFFF0, 0xF000,
    0xF710, 0x008E, 0x7100, 0x08CE,
    0x008C, 0x7310, 0x3100, 0x8CCE,
    0x088C, 0x3110, 0x6666, 0x366C,
    0x17E8, 0x0FF0, 0x718E, 0x399C,
    0xaaaa, 0xf0f0, 0x5a5a, 0x33cc, 
    0x3c3c, 0x55aa, 0x9696, 0xa55a, 
    0x73ce, 0x13c8, 0x324c, 0x3bdc, 
    0x6996, 0xc33c, 0x9966, 0x660, 
    0x272, 0x4e4, 0x4e40, 0x2720, 
    0xc936, 0x936c, 0x39c6, 0x639c, 
    0x9336, 0x9cc6, 0x817e, 0xe718, 
    0xccf0, 0xfcc, 0x7744, 0xee22, 
};
const uint candidateSectionBit2[64] = //Associated to partition 64-127
{
    0xaa685050, 0x6a5a5040, 0x5a5a4200, 0x5450a0a8,
    0xa5a50000, 0xa0a05050, 0x5555a0a0, 0x5a5a5050,
    0xaa550000, 0xaa555500, 0xaaaa5500, 0x90909090,
    0x94949494, 0xa4a4a4a4, 0xa9a59450, 0x2a0a4250,
    0xa5945040, 0x0a425054, 0xa5a5a500, 0x55a0a0a0,
    0xa8a85454, 0x6a6a4040, 0xa4a45000, 0x1a1a0500,
    0x0050a4a4, 0xaaa59090, 0x14696914, 0x69691400,
    0xa08585a0, 0xaa821414, 0x50a4a450, 0x6a5a0200,
    0xa9a58000, 0x5090a0a8, 0xa8a09050, 0x24242424,
    0x00aa5500, 0x24924924, 0x24499224, 0x50a50a50,
    0x500aa550, 0xaaaa4444, 0x66660000, 0xa5a0a5a0,
    0x50a050a0, 0x69286928, 0x44aaaa44, 0x66666600,
    0xaa444444, 0x54a854a8, 0x95809580, 0x96969600,
    0xa85454a8, 0x80959580, 0xaa141414, 0x96960000,
    0xaaaa1414, 0xa05050a0, 0xa0a5a5a0, 0x96000000,
    0x40804080, 0xa9a8a9a8, 0xaaaaaa44, 0x2a4a5254,
};
const uvec2 candidateFixUpIndex1D[128] = 
{
    {15, 0},{15, 0},{15, 0},{15, 0},
    {15, 0},{15, 0},{15, 0},{15, 0},
    {15, 0},{15, 0},{15, 0},{15, 0},
    {15, 0},{15, 0},{15, 0},{15, 0},
    {15, 0},{ 2, 0},{ 8, 0},{ 2, 0},
    { 2, 0},{ 8, 0},{ 8, 0},{15, 0},
    { 2, 0},{ 8, 0},{ 2, 0},{ 2, 0},
    { 8, 0},{ 8, 0},{ 2, 0},{ 2, 0},
    
    {15, 0},{15, 0},{ 6, 0},{ 8, 0},
    { 2, 0},{ 8, 0},{15, 0},{15, 0},
    { 2, 0},{ 8, 0},{ 2, 0},{ 2, 0},
    { 2, 0},{15, 0},{15, 0},{ 6, 0},
    { 6, 0},{ 2, 0},{ 6, 0},{ 8, 0},
    {15, 0},{15, 0},{ 2, 0},{ 2, 0},
    {15, 0},{15, 0},{15, 0},{15, 0},
    {15, 0},{ 2, 0},{ 2, 0},{15, 0},
    //candidateFixUpIndex1D[i][1], i < 64 should not be used
    
    { 3,15},{ 3, 8},{15, 8},{15, 3},
    { 8,15},{ 3,15},{15, 3},{15, 8},
    { 8,15},{ 8,15},{ 6,15},{ 6,15},
    { 6,15},{ 5,15},{ 3,15},{ 3, 8},
    { 3,15},{ 3, 8},{ 8,15},{15, 3},
    { 3,15},{ 3, 8},{ 6,15},{10, 8},
    { 5, 3},{ 8,15},{ 8, 6},{ 6,10},
    { 8,15},{ 5,15},{15,10},{15, 8},
    
    { 8,15},{15, 3},{ 3,15},{ 5,10},
    { 6,10},{10, 8},{ 8, 9},{15,10},
    {15, 6},{ 3,15},{15, 8},{ 5,15},
    {15, 3},{15, 6},{15, 6},{15, 8}, //The Spec doesn't mark the first fixed up index in this row, so I apply 15 for them, and seems correct
    { 3,15},{15, 3},{ 5,15},{ 5,15},
    { 5,15},{ 8,15},{ 5,15},{10,15},
    { 5,15},{10,15},{ 8,15},{13,15},
    {15, 3},{12,15},{ 3,15},{ 3, 8},
};
const uvec2 candidateFixUpIndex1DOrdered[128] = //Same with candidateFixUpIndex1D but order the result when i >= 64
{
    {15, 0},{15, 0},{15, 0},{15, 0},
    {15, 0},{15, 0},{15, 0},{15, 0},
    {15, 0},{15, 0},{15, 0},{15, 0},
    {15, 0},{15, 0},{15, 0},{15, 0},
    {15, 0},{ 2, 0},{ 8, 0},{ 2, 0},
    { 2, 0},{ 8, 0},{ 8, 0},{15, 0},
    { 2, 0},{ 8, 0},{ 2, 0},{ 2, 0},
    { 8, 0},{ 8, 0},{ 2, 0},{ 2, 0},
    
    {15, 0},{15, 0},{ 6, 0},{ 8, 0},
    { 2, 0},{ 8, 0},{15, 0},{15, 0},
    { 2, 0},{ 8, 0},{ 2, 0},{ 2, 0},
    { 2, 0},{15, 0},{15, 0},{ 6, 0},
    { 6, 0},{ 2, 0},{ 6, 0},{ 8, 0},
    {15, 0},{15, 0},{ 2, 0},{ 2, 0},
    {15, 0},{15, 0},{15, 0},{15, 0},
    {15, 0},{ 2, 0},{ 2, 0},{15, 0},
    //candidateFixUpIndex1DOrdered[i][1], i < 64 should not be used
    
    { 3,15},{ 3, 8},{ 8,15},{ 3,15},
    { 8,15},{ 3,15},{ 3,15},{ 8,15},
    { 8,15},{ 8,15},{ 6,15},{ 6,15},
    { 6,15},{ 5,15},{ 3,15},{ 3, 8},
    { 3,15},{ 3, 8},{ 8,15},{ 3,15},
    { 3,15},{ 3, 8},{ 6,15},{ 8,10},
    { 3, 5},{ 8,15},{ 6, 8},{ 6,10},
    { 8,15},{ 5,15},{10,15},{ 8,15},
    
    { 8,15},{ 3,15},{ 3,15},{ 5,10},
    { 6,10},{ 8,10},{ 8, 9},{10,15},
    { 6,15},{ 3,15},{ 8,15},{ 5,15},
    { 3,15},{ 6,15},{ 6,15},{ 8,15}, //The Spec doesn't mark the first fixed up index in this row, so I apply 15 for them, and seems correct
    { 3,15},{ 3,15},{ 5,15},{ 5,15},
    { 5,15},{ 8,15},{ 5,15},{10,15},
    { 5,15},{10,15},{ 8,15},{13,15},
    { 3,15},{12,15},{ 3,15},{ 3, 8},
};

                        //4 bit index: 0, 4, 9, 13, 17, 21, 26, 30, 34, 38, 43, 47, 51, 55, 60, 64
const uint aStep[3][64] = { { 0, 0, 0, 1, 1, 1, 1, 2,
                              2, 2, 2, 2, 3, 3, 3, 3,
                              4, 4, 4, 4, 5, 5, 5, 5,
                              6, 6, 6, 6, 6, 7, 7, 7,
                              7, 8, 8, 8, 8, 9, 9, 9,
                              9,10,10,10,10,10,11,11,
                              11,11,12,12,12,12,13,13,
                              13,13,14,14,14,14,15,15 },
                        //3 bit index: 0, 9, 18, 27, 37, 46, 55, 64
                              { 0,0,0,0,0,1,1,1,
                              1,1,1,1,1,1,2,2,
                              2,2,2,2,2,2,2,3,
                              3,3,3,3,3,3,3,3,
                              3,4,4,4,4,4,4,4,
                              4,4,5,5,5,5,5,5,
                              5,5,5,6,6,6,6,6,
                              6,6,6,6,7,7,7,7 },
                        //2 bit index: 0, 21, 43, 64
                              { 0,0,0,0,0,0,0,0,
                              0,0,0,1,1,1,1,1,
                              1,1,1,1,1,1,1,1,
                              1,1,1,1,1,1,1,1,
                              1,2,2,2,2,2,2,2,
                              2,2,2,2,2,2,2,2,
                              2,2,2,2,2,2,3,3,
                              3,3,3,3,3,3,3,3 } };

layout(push_constant) uniform PushConstants {
    uint tex_width;
    uint num_block_x;
    uint format;
    uint mode_id;
    uint start_block_id;
    uint num_total_blocks;
    float alpha_weight;
} push_constants;

struct Matrix2x4
{
    uvec4 rows[2];
};

Matrix2x4 compress_endpoints0( inout Matrix2x4 endPoint, uvec2 P );
Matrix2x4 compress_endpoints1( inout Matrix2x4 endPoint, uvec2 P );
Matrix2x4 compress_endpoints2( inout Matrix2x4 endPoint );
Matrix2x4 compress_endpoints3( inout Matrix2x4 endPoint, uvec2 P );
Matrix2x4 compress_endpoints4( inout Matrix2x4 endPoint );
Matrix2x4 compress_endpoints5( inout Matrix2x4 endPoint );
Matrix2x4 compress_endpoints6(inout Matrix2x4 endPoint, uvec2 P);
Matrix2x4 compress_endpoints7( inout Matrix2x4 endPoint, uvec2 P );

void block_package0( out uvec4 block, uint partition_id, uint threadBase ); 
void block_package1( out uvec4 block, uint partition_id, uint threadBase );
void block_package2( out uvec4 block, uint partition_id, uint threadBase );
void block_package3( out uvec4 block, uint partition_id, uint threadBase ); 
void block_package4( out uvec4 block, uint rotation, uint index_selector, uint threadBase );
void block_package5( out uvec4 block, uint rotation, uint threadBase ); 
void block_package6(out uvec4 block, uint threadBase);
void block_package7( out uvec4 block, uint partition_id, uint threadBase );

void swap(inout uvec4 lhs, inout uvec4 rhs)
{
    uvec4 tmp = lhs;
    lhs = rhs;
    rhs = tmp;
}
void swap(inout uvec3 lhs, inout uvec3 rhs)
{
    uvec3 tmp = lhs;
    lhs = rhs;
    rhs = tmp;
}
void swap(inout uint lhs, inout uint rhs)
{
    uint tmp = lhs;
    lhs = rhs;
    rhs = tmp;
}

layout(set = 0, binding = 0, rgba8ui) uniform readonly uimage2D g_Input; 
layout(std430, set = 0, binding = 1) restrict readonly buffer InBuff
{
  	uvec4 g_InBuff[];
};

layout(std430, set = 1, binding = 0) restrict writeonly buffer OutBuff
{
  	uvec4 g_OutBuff[];  
};

#define THREAD_GROUP_SIZE	64
#define BLOCK_SIZE_Y		4
#define BLOCK_SIZE_X		4
#define BLOCK_SIZE			(BLOCK_SIZE_Y * BLOCK_SIZE_X)

struct BufferShared
{
    uvec4 pixel;
    uint error;
    uint mode;
    uint partition_id;
    uint index_selector;
    uint rotation;
    uvec4 endPoint_low;
    uvec4 endPoint_high;
    uvec4 endPoint_low_quantized;
    uvec4 endPoint_high_quantized;
};
shared BufferShared shared_temp[THREAD_GROUP_SIZE];

layout (local_size_x = THREAD_GROUP_SIZE) in;
void main()
{
    const uint MAX_USED_THREAD = 16;
    uint BLOCK_IN_GROUP = THREAD_GROUP_SIZE / MAX_USED_THREAD;
    uint blockInGroup = gl_LocalInvocationIndex / MAX_USED_THREAD;
    uint blockID = push_constants.start_block_id + gl_WorkGroupID.x * BLOCK_IN_GROUP + blockInGroup;
    uint threadBase = blockInGroup * MAX_USED_THREAD;
    uint threadInBlock = gl_LocalInvocationIndex - threadBase;
    
    if (blockID >= push_constants.num_total_blocks)
    {
        return;
    }
    
    uint block_y = blockID / push_constants.num_block_x;
    uint block_x = blockID - block_y * push_constants.num_block_x;
    uint base_x = block_x * BLOCK_SIZE_X;
    uint base_y = block_y * BLOCK_SIZE_Y;

    uint mode = g_InBuff[blockID].y & 0x7FFFFFFF;
    uint partition_id = g_InBuff[blockID].z;
    uint index_selector = (g_InBuff[blockID].y >> 31) & 1;
    uint rotation = g_InBuff[blockID].w;
    
    if (threadInBlock < 16)
    {
        ivec2 coord = ivec2(base_x + threadInBlock % 4, base_y + threadInBlock / 4);
        uvec4 pixel = imageLoad(g_Input, coord);

        if ((4 == mode) || (5 == mode))
        {
            if (1 == rotation)
            {
                pixel.ra = pixel.ar;
            }
            else if (2 == rotation)
            {
                pixel.ga = pixel.ag;
            }
            else if (3 == rotation)
            {
                pixel.ba = pixel.ab;
            }
        }

        shared_temp[gl_LocalInvocationIndex].pixel = pixel;
    }

    uint bits = candidateSectionBit[partition_id];
    uint bits2 = candidateSectionBit2[partition_id - 64];

    Matrix2x4 ep;
    ep.rows[0] = uvec4(MAX_UINT);
    ep.rows[1] = uvec4(MIN_UINT);
    Matrix2x4 ep_quantized;
    for (int ii = 2; ii >= 0; -- ii)
    {
        if (threadInBlock < 16)
        {
            Matrix2x4 ep;
            ep.rows[0] = uvec4(MAX_UINT);
            ep.rows[1] = uvec4(MIN_UINT);

            uvec4 pixel = shared_temp[gl_LocalInvocationIndex].pixel;

            uint subset_index = ( bits >> threadInBlock ) & 0x01;
            uint subset_index2 = ( bits2 >> ( threadInBlock * 2 ) ) & 0x03;
            if (0 == ii)
            {
                if ((0 == mode) || (2 == mode))
                {
                    if (0 == subset_index2)
                    {
                        ep.rows[0] = ep.rows[1] = pixel;
                    }
                }
                else if ((1 == mode) || (3 == mode) || (7 == mode))
                {
                    if (0 == subset_index)
                    {
                        ep.rows[0] = ep.rows[1] = pixel;
                    }
                }
                else if ((4 == mode) || (5 == mode) || (6 == mode))
                {
                    ep.rows[0] = ep.rows[1] = pixel;
                }
            }
            else if (1 == ii)
            {
                if ((0 == mode) || (2 == mode))
                {
                    if (1 == subset_index2)
                    {
                        ep.rows[0] = ep.rows[1] = pixel;
                    }
                }
                else if ((1 == mode) || (3 == mode) || (7 == mode))
                {
                    if (1 == subset_index)
                    {
                        ep.rows[0] = ep.rows[1] = pixel;
                    }
                }
            }
            else
            {
                if ((0 == mode) || (2 == mode))
                {
                    if (2 == subset_index2)
                    {
                        ep.rows[0] = ep.rows[1] = pixel;
                    }
                }
            }

            shared_temp[gl_LocalInvocationIndex].endPoint_low = ep.rows[0];
            shared_temp[gl_LocalInvocationIndex].endPoint_high = ep.rows[1];
        }

        if (threadInBlock < 8)
        {
            shared_temp[gl_LocalInvocationIndex].endPoint_low = min(shared_temp[gl_LocalInvocationIndex].endPoint_low, shared_temp[gl_LocalInvocationIndex + 8].endPoint_low);
            shared_temp[gl_LocalInvocationIndex].endPoint_high = max(shared_temp[gl_LocalInvocationIndex].endPoint_high, shared_temp[gl_LocalInvocationIndex + 8].endPoint_high);
        }

        if (threadInBlock < 4)
        {
            shared_temp[gl_LocalInvocationIndex].endPoint_low = min(shared_temp[gl_LocalInvocationIndex].endPoint_low, shared_temp[gl_LocalInvocationIndex + 4].endPoint_low);
            shared_temp[gl_LocalInvocationIndex].endPoint_high = max(shared_temp[gl_LocalInvocationIndex].endPoint_high, shared_temp[gl_LocalInvocationIndex + 4].endPoint_high);
        }

        if (threadInBlock < 2)
        {
            shared_temp[gl_LocalInvocationIndex].endPoint_low = min(shared_temp[gl_LocalInvocationIndex].endPoint_low, shared_temp[gl_LocalInvocationIndex + 2].endPoint_low);
            shared_temp[gl_LocalInvocationIndex].endPoint_high = max(shared_temp[gl_LocalInvocationIndex].endPoint_high, shared_temp[gl_LocalInvocationIndex + 2].endPoint_high);
        }

        if (threadInBlock < 1)
        {
            shared_temp[gl_LocalInvocationIndex].endPoint_low = min(shared_temp[gl_LocalInvocationIndex].endPoint_low, shared_temp[gl_LocalInvocationIndex + 1].endPoint_low);
            shared_temp[gl_LocalInvocationIndex].endPoint_high = max(shared_temp[gl_LocalInvocationIndex].endPoint_high, shared_temp[gl_LocalInvocationIndex + 1].endPoint_high);
        }

        if (ii == threadInBlock)
        {
            ep.rows[0] = shared_temp[threadBase].endPoint_low;
            ep.rows[1] = shared_temp[threadBase].endPoint_high;
        }
    }

    if (threadInBlock < 3)
    {
        uvec2 P;
        if (1 == mode)
        {
            P = uvec2((rotation >> threadInBlock) & 1);
        }
        else
        {
            P = uvec2(rotation >> (threadInBlock * 2 + 0), rotation >> (threadInBlock * 2 + 1)) & 1;
        }

        if (0 == mode)
        {
            ep_quantized = compress_endpoints0( ep, P );
        }
        else if (1 == mode)
        {
            ep_quantized = compress_endpoints1( ep, P );
        }
        else if (2 == mode)
        {
            ep_quantized = compress_endpoints2( ep );
        }
        else if (3 == mode)
        {
            ep_quantized = compress_endpoints3( ep, P );
        }
        else if (4 == mode)
        {
            ep_quantized = compress_endpoints4( ep );
        }
        else if (5 == mode)
        {
            ep_quantized = compress_endpoints5( ep );
        }
        else if (6 == mode)
        {
            ep_quantized = compress_endpoints6( ep, P );
        }
        else //if (7 == mode)
        {
            ep_quantized = compress_endpoints7( ep, P );
        }

        ivec4 span = ivec4(ep.rows[1] - ep.rows[0]);
        if (mode < 4)
        {
            span.w = 0;
        }

        if ((4 == mode) || (5 == mode))
        {
            if (0 == threadInBlock)
            {
                ivec2 span_norm_sqr = ivec2( dot( span.rgb, span.rgb ), span.a * span.a );
                ivec2 dotProduct = ivec2( dot( span.rgb, shared_temp[threadBase + 0].pixel.rgb - ep.rows[0].rgb ), span.a * ( shared_temp[threadBase + 0].pixel.a - ep.rows[0].a ) );
                if ( span_norm_sqr.x > 0 && dotProduct.x > 0 && uint( dotProduct.x * 63.49999 ) > uint( 32 * span_norm_sqr.x ) )
                {
                    swap(ep.rows[0].rgb, ep.rows[1].rgb);
                    swap(ep_quantized.rows[0].rgb, ep_quantized.rows[1].rgb);
                }
                if ( span_norm_sqr.y > 0 && dotProduct.y > 0 && uint( dotProduct.y * 63.49999 ) > uint( 32 * span_norm_sqr.y ) )
                {
                    swap(ep.rows[0].a, ep.rows[1].a);
                    swap(ep_quantized.rows[0].a, ep_quantized.rows[1].a);		    
                }
            }
        }
        else //if ((0 == mode) || (2 == mode) || (1 == mode) || (3 == mode) || (7 == mode) || (6 == mode))
        {
            uint p;
            if (0 == threadInBlock)
            {
                p = 0;
            }
            else if (1 == threadInBlock)
            {
                p = candidateFixUpIndex1D[partition_id].x;
            }
            else //if (2 == threadInBlock)
            {
                p = candidateFixUpIndex1D[partition_id].y;
            }

            int span_norm_sqr = int(dot( span, span ));
            int dotProduct = int(dot( span, shared_temp[threadBase + p].pixel - ep.rows[0] ));
            if ( span_norm_sqr > 0 && dotProduct > 0 && uint( dotProduct * 63.49999 ) > uint( 32 * span_norm_sqr ) )
            {
                swap(ep.rows[0], ep.rows[1]);
                swap(ep_quantized.rows[0], ep_quantized.rows[1]);		
            }
        }

        shared_temp[gl_LocalInvocationIndex].endPoint_low = ep.rows[0];
        shared_temp[gl_LocalInvocationIndex].endPoint_high = ep.rows[1];
        shared_temp[gl_LocalInvocationIndex].endPoint_low_quantized = ep_quantized.rows[0];
        shared_temp[gl_LocalInvocationIndex].endPoint_high_quantized = ep_quantized.rows[1];
    }

    if (threadInBlock < 16)
    {
        uint color_index = 0;
        uint alpha_index = 0;

        Matrix2x4 ep;

        uvec2 indexPrec;
        if ((0 == mode) || (1 == mode))
        {
            indexPrec = uvec2(1);
        }
        else if (6 == mode)
        {
            indexPrec = uvec2(0);
        }
        else if (4 == mode)
        {
            if (0 == index_selector)
            {
                indexPrec = uvec2(2, 1);
            }
            else
            {
                indexPrec = uvec2(1, 2);
            }
        }
        else
        {
            indexPrec = uvec2(2);
        }

        int subset_index;
        if ((0 == mode) || (2 == mode))
        {
            subset_index = int((bits2 >> (threadInBlock * 2)) & 0x03);
        }
        else if ((1 == mode) || (3 == mode) || (7 == mode))
        {
            subset_index = int((bits >> threadInBlock) & 0x01);
        }
        else
        {
            subset_index = 0;
        }

        ep.rows[0] = shared_temp[threadBase + subset_index].endPoint_low;
        ep.rows[1] = shared_temp[threadBase + subset_index].endPoint_high;

        ivec4 span = ivec4(ep.rows[1] - ep.rows[0]);
        if (mode < 4)
        {
            span.w = 0;
        }

        if ((4 == mode) || (5 == mode))
        {
            ivec2 span_norm_sqr;
            span_norm_sqr.x = int(dot( span.rgb, span.rgb ));
            span_norm_sqr.y = span.a * span.a;
            
            int dotProduct = int(dot( span.rgb, shared_temp[threadBase + threadInBlock].pixel.rgb - ep.rows[0].rgb ));
            color_index = ( span_norm_sqr.x <= 0 || dotProduct <= 0 ) ? 0
                    : ( ( dotProduct < span_norm_sqr.x ) ? aStep[indexPrec.x][ uint( dotProduct * 63.49999 / span_norm_sqr.x ) ] : aStep[indexPrec.x][63] );
            dotProduct = int(dot( span.a, shared_temp[threadBase + threadInBlock].pixel.a - ep.rows[0].a ));
            alpha_index = ( span_norm_sqr.y <= 0 || dotProduct <= 0 ) ? 0
                    : ( ( dotProduct < span_norm_sqr.y ) ? aStep[indexPrec.y][ uint( dotProduct * 63.49999 / span_norm_sqr.y ) ] : aStep[indexPrec.y][63] );

            if (index_selector > 0)
            {
                swap(color_index, alpha_index);
            }
        }
        else
        {
            int span_norm_sqr = int(dot( span, span ));

            int dotProduct = int(dot( span, shared_temp[threadBase + threadInBlock].pixel - ep.rows[0] ));
            color_index = ( span_norm_sqr <= 0 || dotProduct <= 0 ) ? 0
                    : ( ( dotProduct < span_norm_sqr ) ? aStep[indexPrec.x][ uint( dotProduct * 63.49999 / span_norm_sqr ) ] : aStep[indexPrec.x][63] );
        }

        shared_temp[gl_LocalInvocationIndex].error = color_index;
        shared_temp[gl_LocalInvocationIndex].mode = alpha_index;
    }

    if (0 == threadInBlock)
    {
        uvec4 block;
        if (0 == mode)
        {
            block_package0( block, partition_id, threadBase );
        }
        else if (1 == mode)
        {
            block_package1( block, partition_id, threadBase );
        }
        else if (2 == mode)
        {
            block_package2( block, partition_id, threadBase );
        }
        else if (3 == mode)
        {
            block_package3( block, partition_id, threadBase );
        }
        else if (4 == mode)
        {
            block_package4( block, rotation, index_selector, threadBase );
        }
        else if (5 == mode)
        {
            block_package5( block, rotation, threadBase );
        }
        else if (6 == mode)
        {
            block_package6( block, threadBase );
        }
        else //if (7 == mode)
        {
            block_package7( block, partition_id, threadBase );
        }

        g_OutBuff[blockID] = block;
    }
}

uint quantize( uint color, uint uPrec )
{
	return (((color << 8) + color) * ((1 << uPrec) - 1) + 32768) >> 16;
}
uvec4 quantize( uvec4 color, uint uPrec )
{
	return (((color << 8) + color) * ((1 << uPrec) - 1) + 32768) >> 16;
}
uint unquantize( uint color, uint uPrec )
{
    color = color << (8 - uPrec);
    return color | (color >> uPrec);
}
uvec4 unquantize( uvec4 color, uint uPrec )
{
    color = color << (8 - uPrec);
    return color | (color >> uPrec);
}

Matrix2x4 compress_endpoints0( inout Matrix2x4 endPoint, uvec2 P )
{
    Matrix2x4 quantized;
    for ( uint j = 0; j < 2; j ++ )
    {
        quantized.rows[j].rgb = quantize(endPoint.rows[j].rgbb, 5).rgb & 0xFFFFFFFE;
	    quantized.rows[j].rgb |= P[j];
        quantized.rows[j].a = 0xFF;

        endPoint.rows[j].rgb = unquantize(quantized.rows[j].rgbb, 5).rgb;
        endPoint.rows[j].a = 0xFF;

        quantized.rows[j] <<= 3;
    }
    return quantized;
}
Matrix2x4 compress_endpoints1( inout Matrix2x4 endPoint, uvec2 P )
{
    Matrix2x4 quantized;
    for ( uint j = 0; j < 2; j ++ )
    {
        quantized.rows[j].rgb = quantize(endPoint.rows[j].rgbb, 7).rgb & 0xFFFFFFFE;
	    quantized.rows[j].rgb |= P[j];
        quantized.rows[j].a = 0xFF;

        endPoint.rows[j].rgb = unquantize(quantized.rows[j].rgbb, 7).rgb;
	    endPoint.rows[j].a = 0xFF;

        quantized.rows[j] <<= 1;
    }
    return quantized;
}
Matrix2x4 compress_endpoints2( inout Matrix2x4 endPoint )
{
    Matrix2x4 quantized;
    for ( uint j = 0; j < 2; j ++ )
    {
        quantized.rows[j].rgb = quantize(endPoint.rows[j].rgbb, 5).rgb;
        quantized.rows[j].a = 0xFF;

        endPoint.rows[j].rgb = unquantize(quantized.rows[j].rgbb, 5).rgb;
	    endPoint.rows[j].a = 0xFF;    

        quantized.rows[j] <<= 3;
    }
    return quantized;
}
Matrix2x4 compress_endpoints3( inout Matrix2x4 endPoint, uvec2 P )
{
    Matrix2x4 quantized;
    for ( uint j = 0; j < 2; j ++ )
    {
        quantized.rows[j].rgb = endPoint.rows[j].rgb & 0xFFFFFFFE;
	    quantized.rows[j].rgb |= P[j];
        quantized.rows[j].a = 0xFF;
        
        endPoint.rows[j].rgb = quantized.rows[j].rgb;
        endPoint.rows[j].a = 0xFF;
    }
    return quantized;
}
Matrix2x4 compress_endpoints4( inout Matrix2x4 endPoint )
{
    Matrix2x4 quantized;
    for ( uint j = 0; j < 2; j ++ )
    {
        quantized.rows[j].rgb = quantize(endPoint.rows[j].rgbb, 5).rgb;
        quantized.rows[j].a = quantize(endPoint.rows[j].a, 6).r;
        
        endPoint.rows[j].rgb = unquantize(quantized.rows[j].rgbb, 5).rgb;        
        endPoint.rows[j].a = unquantize(quantized.rows[j].a, 6).r;

        quantized.rows[j].rgb <<= 3;
        quantized.rows[j].a <<= 2;
    }    
    return quantized;
}
Matrix2x4 compress_endpoints5( inout Matrix2x4 endPoint )
{
    Matrix2x4 quantized;
    for ( uint j = 0; j < 2; j ++ )
    {
        quantized.rows[j].rgb = quantize(endPoint.rows[j].rgbb, 7).rgb;
        quantized.rows[j].a = endPoint.rows[j].a;

        endPoint.rows[j].rgb = unquantize(quantized.rows[j].rgbb, 7).rgb;
        // endPoint.rows[j].a   Alpha is full precision

        quantized.rows[j].rgb <<= 1;
    }    
    return quantized;
}
Matrix2x4 compress_endpoints6(inout Matrix2x4 endPoint, uvec2 P)
{
    Matrix2x4 quantized;
    for ( uint j = 0; j < 2; j ++ )
    {
        quantized.rows[j] = endPoint.rows[j] & 0xFFFFFFFE;
	    quantized.rows[j] |= P[j];
	        
        endPoint.rows[j] = quantized.rows[j];
    }
    return quantized;
}
Matrix2x4 compress_endpoints7( inout Matrix2x4 endPoint, uvec2 P )
{
    Matrix2x4 quantized;
    for ( uint j = 0; j < 2; j ++ )
    {
        quantized.rows[j] = quantize(endPoint.rows[j], 6) & 0xFFFFFFFE;
	    quantized.rows[j] |= P[j];

        endPoint.rows[j] = unquantize(quantized.rows[j], 6);
    }
    quantized.rows[0] = quantized.rows[0] << 2;
    quantized.rows[1] = quantized.rows[1] << 2;
    return quantized;
}

#define get_end_point_l(subset) shared_temp[threadBase + subset].endPoint_low_quantized
#define get_end_point_h(subset) shared_temp[threadBase + subset].endPoint_high_quantized
#define get_color_index(index) shared_temp[threadBase + index].error
#define get_alpha_index(index) shared_temp[threadBase + index].mode

void block_package0( out uvec4 block, uint partition_id, uint threadBase )
{
    block.x = 0x01 | ( (partition_id - 64) << 1 ) 
            | ( ( get_end_point_l(0).r & 0xF0 ) <<  1 ) | ( ( get_end_point_h(0).r & 0xF0 ) <<  5 ) 
            | ( ( get_end_point_l(1).r & 0xF0 ) <<  9 ) | ( ( get_end_point_h(1).r & 0xF0 ) << 13 ) 
            | ( ( get_end_point_l(2).r & 0xF0 ) << 17 ) | ( ( get_end_point_h(2).r & 0xF0 ) << 21 ) 
            | ( ( get_end_point_l(0).g & 0xF0 ) << 25 );
    block.y = ( ( get_end_point_l(0).g & 0xF0 ) >>  7 ) | ( ( get_end_point_h(0).g & 0xF0 ) >>  3 ) 
            | ( ( get_end_point_l(1).g & 0xF0 ) <<  1 ) | ( ( get_end_point_h(1).g & 0xF0 ) <<  5 ) 
            | ( ( get_end_point_l(2).g & 0xF0 ) <<  9 ) | ( ( get_end_point_h(2).g & 0xF0 ) << 13 ) 
            | ( ( get_end_point_l(0).b & 0xF0 ) << 17 ) | ( ( get_end_point_h(0).b & 0xF0 ) << 21 )
            | ( ( get_end_point_l(1).b & 0xF0 ) << 25 );
    block.z = ( ( get_end_point_l(1).b & 0xF0 ) >>  7 ) | ( ( get_end_point_h(1).b & 0xF0 ) >>  3 ) 
            | ( ( get_end_point_l(2).b & 0xF0 ) <<  1 ) | ( ( get_end_point_h(2).b & 0xF0 ) <<  5 ) 
            | ( ( get_end_point_l(0).r & 0x08 ) << 10 ) | ( ( get_end_point_h(0).r & 0x08 ) << 11 ) 
            | ( ( get_end_point_l(1).r & 0x08 ) << 12 ) | ( ( get_end_point_h(1).r & 0x08 ) << 13 ) 
            | ( ( get_end_point_l(2).r & 0x08 ) << 14 ) | ( ( get_end_point_h(2).r & 0x08 ) << 15 )
            | ( get_color_index(0) << 19 );
    block.w = 0;
    uint i = 1;
    for ( ; i <= min( candidateFixUpIndex1DOrdered[partition_id][0], 4 ); i ++ )
    {
        block.z |= get_color_index(i) << ( i * 3 + 18 );
    }
    if ( candidateFixUpIndex1DOrdered[partition_id][0] < 4 ) //i = 4
    {
        block.z |= get_color_index(4) << 29;
        i += 1;
    }
    else //i = 5
    {
        block.w |= ( get_color_index(4) & 0x04 ) >> 2;
        for ( ; i <= candidateFixUpIndex1DOrdered[partition_id][0]; i ++ )
            block.w |= get_color_index(i) << ( i * 3 - 14 );
    }
    for ( ; i <= candidateFixUpIndex1DOrdered[partition_id][1]; i ++ )
    {
        block.w |= get_color_index(i) << ( i * 3 - 15 );
    }
    for ( ; i < 16; i ++ )
    {
        block.w |= get_color_index(i) << ( i * 3 - 16 );
    }
}
void block_package1( out uvec4 block, uint partition_id, uint threadBase )
{
    block.x = 0x02 | ( partition_id << 2 ) 
            | ( ( get_end_point_l(0).r & 0xFC ) <<  6 ) | ( ( get_end_point_h(0).r & 0xFC ) << 12 ) 
            | ( ( get_end_point_l(1).r & 0xFC ) << 18 ) | ( ( get_end_point_h(1).r & 0xFC ) << 24 );
    block.y = ( ( get_end_point_l(0).g & 0xFC ) >>  2 ) | ( ( get_end_point_h(0).g & 0xFC ) <<  4 ) 
            | ( ( get_end_point_l(1).g & 0xFC ) << 10 ) | ( ( get_end_point_h(1).g & 0xFC ) << 16 )
            | ( ( get_end_point_l(0).b & 0xFC ) << 22 ) | ( ( get_end_point_h(0).b & 0xFC ) << 28 );
    block.z = ( ( get_end_point_h(0).b & 0xFC ) >>  4 ) | ( ( get_end_point_l(1).b & 0xFC ) <<  2 )
            | ( ( get_end_point_h(1).b & 0xFC ) <<  8 ) 
            | ( ( get_end_point_l(0).r & 0x02 ) << 15 ) | ( ( get_end_point_l(1).r & 0x02 ) << 16 )
            | ( get_color_index(0) << 18 );
    if ( candidateFixUpIndex1DOrdered[partition_id][0] == 15 )
    {
        block.w = (get_color_index(15) << 30) | (get_color_index(14) << 27) | (get_color_index(13) << 24) | (get_color_index(12) << 21) | (get_color_index(11) << 18) | (get_color_index(10) << 15)
            | (get_color_index(9) << 12) | (get_color_index(8) << 9) | (get_color_index(7) << 6) | (get_color_index(6) << 3) | get_color_index(5);
        block.z |= (get_color_index(4) << 29) | (get_color_index(3) << 26) | (get_color_index(2) << 23) | (get_color_index(1) << 20) | (get_color_index(0) << 18);
    }
    else if ( candidateFixUpIndex1DOrdered[partition_id][0] == 2 )
    {
        block.w = (get_color_index(15) << 29) | (get_color_index(14) << 26) | (get_color_index(13) << 23) | (get_color_index(12) << 20) | (get_color_index(11) << 17) | (get_color_index(10) << 14)
            | (get_color_index(9) << 11) | (get_color_index(8) << 8) | (get_color_index(7) << 5) | (get_color_index(6) << 2) | (get_color_index(5) >> 1);
        block.z |= (get_color_index(5) << 31) | (get_color_index(4) << 28) | (get_color_index(3) << 25) | (get_color_index(2) << 23) | (get_color_index(1) << 20) | (get_color_index(0) << 18);
    }
    else if ( candidateFixUpIndex1DOrdered[partition_id][0] == 8 )
    {
        block.w = (get_color_index(15) << 29) | (get_color_index(14) << 26) | (get_color_index(13) << 23) | (get_color_index(12) << 20) | (get_color_index(11) << 17) | (get_color_index(10) << 14)
            | (get_color_index(9) << 11) | (get_color_index(8) << 9) | (get_color_index(7) << 6) | (get_color_index(6) << 3) | get_color_index(5);
        block.z |= (get_color_index(4) << 29) | (get_color_index(3) << 26) | (get_color_index(2) << 23) | (get_color_index(1) << 20) | (get_color_index(0) << 18);
    }
    else //candidateFixUpIndex1DOrdered[partition_id] == 6
    {
        block.w = (get_color_index(15) << 29) | (get_color_index(14) << 26) | (get_color_index(13) << 23) | (get_color_index(12) << 20) | (get_color_index(11) << 17) | (get_color_index(10) << 14)
            | (get_color_index(9) << 11) | (get_color_index(8) << 8) | (get_color_index(7) << 5) | (get_color_index(6) << 3) | get_color_index(5);
        block.z |= (get_color_index(4) << 29) | (get_color_index(3) << 26) | (get_color_index(2) << 23) | (get_color_index(1) << 20) | (get_color_index(0) << 18);
    }
}
void block_package2( out uvec4 block, uint partition_id, uint threadBase )
{
    block.x = 0x04 | ( (partition_id - 64) << 3 ) 
            | ( ( get_end_point_l(0).r & 0xF8 ) <<  6 ) | ( ( get_end_point_h(0).r & 0xF8 ) << 11 ) 
            | ( ( get_end_point_l(1).r & 0xF8 ) << 16 ) | ( ( get_end_point_h(1).r & 0xF8 ) << 21 ) 
            | ( ( get_end_point_l(2).r & 0xF8 ) << 26 );
    block.y = ( ( get_end_point_l(2).r & 0xF8 ) >>  6 ) | ( ( get_end_point_h(2).r & 0xF8 ) >>  1 )
            | ( ( get_end_point_l(0).g & 0xF8 ) <<  4 ) | ( ( get_end_point_h(0).g & 0xF8 ) <<  9 ) 
            | ( ( get_end_point_l(1).g & 0xF8 ) << 14 ) | ( ( get_end_point_h(1).g & 0xF8 ) << 19 ) 
            | ( ( get_end_point_l(2).g & 0xF8 ) << 24 );
    block.z = ( ( get_end_point_h(2).g & 0xF8 ) >>  3 ) | ( ( get_end_point_l(0).b & 0xF8 ) <<  2 )
            | ( ( get_end_point_h(0).b & 0xF8 ) <<  7 )	| ( ( get_end_point_l(1).b & 0xF8 ) << 12 )
            | ( ( get_end_point_h(1).b & 0xF8 ) << 17 ) | ( ( get_end_point_l(2).b & 0xF8 ) << 22 ) 
            | ( ( get_end_point_h(2).b & 0xF8 ) << 27 );
    block.w = ( ( get_end_point_h(2).b & 0xF8 ) >>  5 ) 
            | ( get_color_index(0) << 3 );
    uint i = 1;
    for ( ; i <= candidateFixUpIndex1DOrdered[partition_id][0]; i ++ )
    {
        block.w |= get_color_index(i) << ( i * 2 + 2 );
    }
    for ( ; i <= candidateFixUpIndex1DOrdered[partition_id][1]; i ++ )
    {
        block.w |= get_color_index(i) << ( i * 2 + 1 );
    }
    for ( ; i < 16; i ++ )
    {
        block.w |= get_color_index(i) << ( i * 2 );
    }
}
void block_package3( out uvec4 block, uint partition_id, uint threadBase )
{
    block.x = 0x08 | ( partition_id << 4 ) 
            | ( ( get_end_point_l(0).r & 0xFE ) <<  9 ) | ( ( get_end_point_h(0).r & 0xFE ) << 16 ) 
            | ( ( get_end_point_l(1).r & 0xFE ) << 23 ) | ( ( get_end_point_h(1).r & 0xFE ) << 30 );
    block.y = ( ( get_end_point_h(1).r & 0xFE ) >>  2 ) | ( ( get_end_point_l(0).g & 0xFE ) <<  5 )
            | ( ( get_end_point_h(0).g & 0xFE ) << 12 ) | ( ( get_end_point_l(1).g & 0xFE ) << 19 )
            | ( ( get_end_point_h(1).g & 0xFE ) << 26 );
    block.z = ( ( get_end_point_h(1).g & 0xFE ) >>  6 ) | ( ( get_end_point_l(0).b & 0xFE ) <<  1 )
            | ( ( get_end_point_h(0).b & 0xFE ) <<  8 ) | ( ( get_end_point_l(1).b & 0xFE ) << 15 )
            | ( ( get_end_point_h(1).b & 0xFE ) << 22 )
            | ( ( get_end_point_l(0).r & 0x01 ) << 30 ) | ( ( get_end_point_h(0).r & 0x01 ) << 31 );
    block.w = ( ( get_end_point_l(1).r & 0x01 ) <<  0 ) | ( ( get_end_point_h(1).r & 0x01 ) <<  1 )
            | ( get_color_index(0) << 2 );
    uint i = 1;
    for ( ; i <= candidateFixUpIndex1DOrdered[partition_id][0]; i ++ )
    {
        block.w |= get_color_index(i) << ( i * 2 + 1 );
    }
    for ( ; i < 16; i ++ )
    {
        block.w |= get_color_index(i) << ( i * 2 );
    }
}
void block_package4( out uvec4 block, uint rotation, uint index_selector, uint threadBase )
{
    block.x = 0x10 | ( (rotation & 3) << 5 ) | ( (index_selector & 1) << 7 )
            | ( ( get_end_point_l(0).r & 0xF8 ) <<  5 ) | ( ( get_end_point_h(0).r & 0xF8 ) << 10 )
            | ( ( get_end_point_l(0).g & 0xF8 ) << 15 ) | ( ( get_end_point_h(0).g & 0xF8 ) << 20 )
            | ( ( get_end_point_l(0).b & 0xF8 ) << 25 );

    block.y = ( ( get_end_point_l(0).b & 0xF8 ) >>  7 ) | ( ( get_end_point_h(0).b & 0xF8 ) >>  2 )
            | ( ( get_end_point_l(0).a & 0xFC ) <<  4 ) | ( ( get_end_point_h(0).a & 0xFC ) << 10 )
            | ( (get_color_index(0) & 1) << 18 ) | ( get_color_index(1) << 19 ) | ( get_color_index(2) << 21 ) | ( get_color_index(3) << 23 ) 
            | ( get_color_index(4) << 25 ) | ( get_color_index(5) << 27 ) | ( get_color_index(6) << 29 ) | ( get_color_index(7) << 31 );

    block.z = ( get_color_index(7) >>  1 ) | ( get_color_index(8) <<  1 ) | ( get_color_index(9) <<  3 ) | ( get_color_index(10)<<  5 )
            | ( get_color_index(11)<<  7 ) | ( get_color_index(12)<<  9 ) | ( get_color_index(13)<< 11 ) | ( get_color_index(14)<< 13 )
            | ( get_color_index(15)<< 15 ) | ( (get_alpha_index(0) & 3) << 17 ) | ( get_alpha_index(1) << 19 ) | ( get_alpha_index(2) << 22 )
            | ( get_alpha_index(3) << 25 ) | ( get_alpha_index(4) << 28 ) | ( get_alpha_index(5) << 31 );

    block.w = ( get_alpha_index(5) >>  1 ) | ( get_alpha_index(6) <<  2 ) | ( get_alpha_index(7) <<  5 ) | ( get_alpha_index(8) <<  8 ) 
            | ( get_alpha_index(9) << 11 ) | ( get_alpha_index(10)<< 14 ) | ( get_alpha_index(11)<< 17 ) | ( get_alpha_index(12)<< 20 ) 
            | ( get_alpha_index(13)<< 23 ) | ( get_alpha_index(14)<< 26 ) | ( get_alpha_index(15)<< 29 );
}
void block_package5( out uvec4 block, uint rotation, uint threadBase )
{
    block.x = 0x20 | ( rotation << 6 )
            | ( ( get_end_point_l(0).r & 0xFE ) <<  7 ) | ( ( get_end_point_h(0).r & 0xFE ) << 14 )
            | ( ( get_end_point_l(0).g & 0xFE ) << 21 ) | ( ( get_end_point_h(0).g & 0xFE ) << 28 );
    block.y = ( ( get_end_point_h(0).g & 0xFE ) >>  4 ) | ( ( get_end_point_l(0).b & 0xFE ) <<  3 )
            | ( ( get_end_point_h(0).b & 0xFE ) << 10 )	| ( get_end_point_l(0).a << 18 ) | ( get_end_point_h(0).a << 26 );
    block.z = ( get_end_point_h(0).a >>  6 )
            | ( get_color_index(0) <<  2 ) | ( get_color_index(1) <<  3 ) | ( get_color_index(2) <<  5 ) | ( get_color_index(3) <<  7 ) 
            | ( get_color_index(4) <<  9 ) | ( get_color_index(5) << 11 ) | ( get_color_index(6) << 13 ) | ( get_color_index(7) << 15 )
            | ( get_color_index(8) << 17 ) | ( get_color_index(9) << 19 ) | ( get_color_index(10)<< 21 ) | ( get_color_index(11)<< 23 ) 
            | ( get_color_index(12)<< 25 ) | ( get_color_index(13)<< 27 ) | ( get_color_index(14)<< 29 ) | ( get_color_index(15)<< 31 );
    block.w =  ( get_color_index(15)>> 1 ) | ( get_alpha_index(0) <<  1 ) | ( get_alpha_index(1) <<  2 ) | ( get_alpha_index(2) <<  4 )
            | ( get_alpha_index(3) <<  6 ) | ( get_alpha_index(4) <<  8 ) | ( get_alpha_index(5) << 10 ) | ( get_alpha_index(6) << 12 )
            | ( get_alpha_index(7) << 14 ) | ( get_alpha_index(8) << 16 ) | ( get_alpha_index(9) << 18 ) | ( get_alpha_index(10)<< 20 ) 
            | ( get_alpha_index(11)<< 22 ) | ( get_alpha_index(12)<< 24 ) | ( get_alpha_index(13)<< 26 ) | ( get_alpha_index(14)<< 28 )
            | ( get_alpha_index(15)<< 30 );
}
void block_package6(out uvec4 block, uint threadBase)
{
    block.x = 0x40
            | ( ( get_end_point_l(0).r & 0xFE ) <<  6 ) | ( ( get_end_point_h(0).r & 0xFE ) << 13 )
            | ( ( get_end_point_l(0).g & 0xFE ) << 20 ) | ( ( get_end_point_h(0).g & 0xFE ) << 27 );
    block.y = ( ( get_end_point_h(0).g & 0xFE ) >>  5 ) | ( ( get_end_point_l(0).b & 0xFE ) <<  2 )
            | ( ( get_end_point_h(0).b & 0xFE ) <<  9 )	| ( ( get_end_point_l(0).a & 0xFE ) << 16 )
            | ( ( get_end_point_h(0).a & 0xFE ) << 23 )
            | ( get_end_point_l(0).r & 0x01 ) << 31;
    block.z = ( get_end_point_h(0).r & 0x01 )
            | ( get_color_index(0) <<  1 ) | ( get_color_index(1) <<  4 ) | ( get_color_index(2) <<  8 ) | ( get_color_index(3) << 12 ) 
            | ( get_color_index(4) << 16 ) | ( get_color_index(5) << 20 ) | ( get_color_index(6) << 24 ) | ( get_color_index(7) << 28 );
    block.w = ( get_color_index(8) <<  0 ) | ( get_color_index(9) <<  4 ) | ( get_color_index(10)<<  8 ) | ( get_color_index(11)<< 12 ) 
            | ( get_color_index(12)<< 16 ) | ( get_color_index(13)<< 20 ) | ( get_color_index(14)<< 24 ) | ( get_color_index(15)<< 28 );
}
void block_package7( out uvec4 block, uint partition_id, uint threadBase )
{
    block.x = 0x80 | ( partition_id << 8 ) 
            | ( ( get_end_point_l(0).r & 0xF8 ) << 11 ) | ( ( get_end_point_h(0).r & 0xF8 ) << 16 ) 
            | ( ( get_end_point_l(1).r & 0xF8 ) << 21 ) | ( ( get_end_point_h(1).r & 0xF8 ) << 26 );
    block.y = ( ( get_end_point_h(1).r & 0xF8 ) >>  6 ) | ( ( get_end_point_l(0).g & 0xF8 ) >>  1 )
            | ( ( get_end_point_h(0).g & 0xF8 ) <<  4 ) | ( ( get_end_point_l(1).g & 0xF8 ) <<  9 ) 
            | ( ( get_end_point_h(1).g & 0xF8 ) << 14 )	| ( ( get_end_point_l(0).b & 0xF8 ) << 19 ) 
            | ( ( get_end_point_h(0).b & 0xF8 ) << 24 );
    block.z = ( ( get_end_point_l(1).b & 0xF8 ) >>  3 )	| ( ( get_end_point_h(1).b & 0xF8 ) <<  2 ) 
            | ( ( get_end_point_l(0).a & 0xF8 ) <<  7 ) | ( ( get_end_point_h(0).a & 0xF8 ) << 12 ) 
            | ( ( get_end_point_l(1).a & 0xF8 ) << 17 ) | ( ( get_end_point_h(1).a & 0xF8 ) << 22 ) 
            | ( ( get_end_point_l(0).r & 0x04 ) << 28 ) | ( ( get_end_point_h(0).r & 0x04 ) << 29 );
    block.w = ( ( get_end_point_l(1).r & 0x04 ) >>  2 ) | ( ( get_end_point_h(1).r & 0x04 ) >>  1 )
            | ( get_color_index(0) <<  2 );
    uint i = 1;
    for ( ; i <= candidateFixUpIndex1DOrdered[partition_id][0]; i ++ )
    {
        block.w |= get_color_index(i) << ( i * 2 + 1 );
    }
    for ( ; i < 16; i ++ )
    {
        block.w |= get_color_index(i) << ( i * 2 );
    }
}
